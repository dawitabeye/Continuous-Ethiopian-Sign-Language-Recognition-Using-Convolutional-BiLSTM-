to Create SSH from network set on Port forwarding private port 22 and public port 9191  and on firewall 0.0.0.0/0 of Source CIDR and start port 9191 and end port 9191 or custome port.
To access the remote ssh
ssh root@196.188.250.164 -p 9191

To share public private key 
First we have to go our local powershell 
key-gen to generate the private key 
then based on the path or xl file copy the private key and go to ssh server 
nano .ssh/authorized_keys then paste on it save and check


to copy file from local computer to remote unprivilaged user 
scp -P 9191 Privatekey.txt dawit2@196.188.250.164:/home/dawit2/Privatekey.txt

appache install and run using IP address and port set 80 for private port and 8888 custom port for public and 0.0.0.0/0 for CIDR and start and end port 8888
then sudo ufw allow 80/tcp 
then check on web browser 196.188.250.164:8888


To schedule everytime logs
* * * * * /bin/date >> /home/dawit1/log_time.txt


to check used port ss -ltnup 

systat -u to check CPU status 
sar -r to check memory status 
sar -b to check disk status
sar -s with specfic time we can see specfic time status

netstat or ss to show listing and non listing porsts (tcp/udp)
netstat -tuln     # Show listening TCP/UDP ports
netstat -an       # Show all connections (numeric)
netstat -rn       # Show routing table
netstat -p        # Show PID and program name

The `free` command in Linux is used to display the amount of **free and used memory** in the system. It shows information about **RAM and swap usage**, as well as **buffers and cache** used by the kernel.

### Common Options:

* `-h` : Human-readable format (e.g., in KB, MB, GB).
* `-m` : Show output in megabytes.
* `-g` : Show output in gigabytes.
* `-b` : Show output in bytes.
* `-t` : Show total of all memory (RAM + swap).
* `-s [seconds]` : Continuously display the memory status every \[seconds].

###############################################################################################################################################
The `df` command in Linux is used to **report disk space usage** of file systems.
### ðŸ”¹ **Commonly Used Options**:

* `-h` : Human-readable format (e.g., KB, MB, GB)
* `-T` : Show file system type
* `-a` : Include pseudo, duplicate, inaccessible file systems
* `-i` : Show inode information instead of block usage
################################################################################################################################################
Sure! Hereâ€™s the **concise command-only version** for **Debian/Ubuntu** to **expand root partition** using unused space:

---


### âœ… Check disk

```bash
sudo fdisk -l
```

---

### âœ… Resize partition

```bash
sudo fdisk /dev/sda
# Inside fdisk:
# p  â†’ print partitions
# d  â†’ delete partition (e.g., 1)
# n  â†’ new partition (same number)
# First sector: same as before
# Last sector: press Enter
# w  â†’ write and exit
```

---

### âœ… Reboot

```bash
sudo reboot
```

---

### âœ… Resize filesystem (ext4)

```bash
sudo resize2fs /dev/sda1
```
### âœ… Check result

```bash
df -h
```
###################################################################################################################################################################3
sudo du -h -d 1 /usr
```
Displays the **disk usage** of each **top-level subdirectory** inside `/usr` in **human-readable** format (e.g., MB/GB).
##################################################################################################################################################################
lsof
```
Lists all **open files** by processes â€” useful for finding which files, sockets, or devices are in use.
###################################################################################################################################################################
**ping** is a network diagnostic tool used to test the reachability of a host on an IP network. It sends ICMP echo request packets and waits for a reply.

**Common options:**

* **-c**: Specifies the number of packets to send. Example: `-c 4` sends 4 pings.
* **-i**: Sets the interval (in seconds) between packets. Default is 1 second.
* **-t**: Sets the time to live (TTL), which limits the number of hops a packet can take.
* **-s**: Defines the packet size in bytes.
* **-4 / -6**: Forces the use of IPv4 or IPv6.

##################################################################################################################################################################
**Fail2Ban** is a popular open-source intrusion prevention tool used to enhance server security. It monitors log files (e.g., `/var/log/auth.log`, `/var/log/nginx/error.log`) to detect patterns of suspicious activity such as failed login attempts, and then automatically takes actionâ€”usually by updating firewall rules to temporarily or permanently ban offending IP addresses.

### Key Features:

* **Brute-force protection**: Commonly protects services like SSH, FTP, SMTP, and web servers from brute-force attacks.
* **Configurable jails**: â€œJailsâ€ define how Fail2Ban monitors specific services and what action to take.
* **Ban automation**: Offending IPs can be banned for a set duration or permanently.
* **Log-based detection**: Uses regex patterns to identify malicious behavior in log files.
* **Custom actions**: Can trigger firewall rules, send email alerts, or even run custom scripts.

### Common Use Cases:

* Protecting SSH access from brute-force attacks.
* Blocking repeated failed login attempts on websites or mail servers.
* Mitigating DDoS or bot-based scanning attempts.

### Example Command:

```bash
sudo fail2ban-client status sshd
```

This shows the status of the `sshd` jail, including how many IPs have been banned.

Would you like a configuration example or how to install and enable it on Ubuntu or CentOS?
########################################################################################################################################################
**Logrotate** is a system utility in Unix/Linux used to manage the automatic rotation, compression, removal, and mailing of log files. It helps prevent log files from consuming excessive disk space and keeps the system organized by managing old logs efficiently.

---

### ðŸ”§ **Key Features of Logrotate:**

* **Automatic log rotation** based on size or time (daily, weekly, monthly).
* **Compression** of old log files (e.g., `.gz`) to save space.
* **Custom retention policies** (e.g., keep last 4 logs, delete older).
* **Pre/post rotation scripts** (e.g., restart services after rotation).
* **Supports multiple configurations** via `/etc/logrotate.d/`.

---

### ðŸ“ **Configuration Files:**

* **Global config**: `/etc/logrotate.conf`
* **Per-service config**: `/etc/logrotate.d/` (e.g., `/etc/logrotate.d/nginx`)

---

### âœ… **Example Configuration:**

```bash
/var/log/nginx/*.log {
    daily
    rotate 14
    compress
    missingok
    notifempty
    postrotate
        systemctl reload nginx > /dev/null 2>&1 || true
    endscript
}
```

This rotates NGINX logs **daily**, keeps **14 old logs**, **compresses** them, and reloads NGINX after rotation.

---

### ðŸ“Œ **Manual Trigger:**

To force log rotation:

```bash
sudo logrotate -f /etc/logrotate.conf
```

To test with verbose output:

```bash
sudo logrotate -d /etc/logrotate.conf
```
###########################################################################################################################################################################

